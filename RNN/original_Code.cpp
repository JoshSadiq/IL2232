
//Hengzhen Yuan wrote on 2024.1.10
//IL2232 project Time series analysis

#include <Arduino.h>
//Ensure that core parameters are not optimized
volatile float output;
volatile float count = 0;

// Define RNN parameters  定义RNN的参数
const int input_size = 1;
const int hidden_size= 16;
const int output_size = 1;


//the weight of RNN    RNN的权重矩阵
float W_ih[hidden_size][input_size]={{-0.0214},
        { 0.3268},
        { 0.7203},
        { 0.0643},
        { 0.6175},
        {-0.1292},
        { 0.4788},
        {-0.2121},
        {-0.2292},
        {-0.0545},
        {-0.7147},
        {-0.9075},
        { 0.5666},
        {-1.1162},
        { 0.6497},
        {-1.8444}};
float W_hh[hidden_size][hidden_size]={{-0.2659, -0.0063,  0.0769,  0.0327,  0.1389, -0.0604,  0.1623, -0.1215,
          0.0024,  0.0579,  0.0250,  0.2307, -0.0927, -0.1638,  0.1374,  0.0282},
        { 0.1753,  0.1666,  0.2251, -0.0280, -0.0176, -0.0401,  0.0368,  0.0926,
          0.0268,  0.1021, -0.0873, -0.2175,  0.0666,  0.1672,  0.0923,  0.2841},
        {-0.3121, -0.2438,  0.3722,  0.2330,  0.0477, -0.0306,  0.0573,  0.0087,
          0.3413,  0.0025,  0.1015,  0.3024, -0.2744,  0.0480, -0.0948, -0.0668},
        { 0.1404, -0.1710,  0.1140, -0.3875,  0.2507, -0.2691, -0.0111,  0.1866,
          0.3820,  0.2673,  0.2742,  0.1858, -0.1401, -0.2974, -0.0607, -0.2628},
        {-0.1382, -0.3221, -0.4433, -0.1651,  0.0371,  0.3586, -0.4665,  0.6174,
          0.1342, -0.2074,  0.0622,  0.4658, -0.1644,  0.5270, -0.2074, -0.2515},
        {-0.0396,  0.2366, -0.0507,  0.0752, -0.3353, -0.7314, -0.0572, -0.1970,
         -0.0846,  0.2881, -0.4311,  0.0630,  0.3810,  0.0523, -0.1119,  0.1107},
        {-0.3017,  0.1387, -0.0883,  0.1970,  0.0729,  0.2929, -0.1084, -0.0947,
         -0.0332, -0.0110,  0.2288, -0.1013,  0.2472,  0.0204,  0.0399, -0.1340},
        { 0.0596, -0.2674, -0.2407, -0.0805,  0.2634,  0.2180, -0.2939, -0.0824,
         -0.0092, -0.2952,  0.0242,  0.3330, -0.2020,  0.6906,  0.3450, -0.1583},
        { 0.1360, -0.1093,  0.2299,  0.1072, -0.0298,  0.0954,  0.1019, -0.1089,
         -0.4767,  0.0280,  0.2412, -0.1016,  0.0359, -0.5382, -0.3091,  0.2139},
        { 0.0282,  0.2126,  0.3603,  0.0303, -0.0228, -0.2164,  0.2371, -0.3304,
         -0.0071,  0.2937,  0.0841, -0.1046,  0.2372, -0.3438,  0.2007,  0.4081},
        { 0.2058,  0.3290,  0.1326, -0.3209, -0.2400, -0.3682,  0.6396, -0.7847,
         -0.3827, -0.0211,  0.0653, -0.6761,  0.4944, -0.3082,  0.0074,  0.5173},
        {-0.2108,  0.0539,  0.2957,  0.1659,  0.2438, -0.1709, -0.0477, -0.1206,
          0.1188,  0.3319,  0.1772,  0.0025, -0.0342, -0.2797,  0.1334, -0.2841},
        { 0.1786, -0.0030, -0.2926, -0.0947, -0.4070, -0.1531, -0.0062,  0.1721,
         -0.2154, -0.4691, -0.0970,  0.0228, -0.2492,  0.4605, -0.1357, -0.3778},
        {-0.1488,  0.2910,  0.0880,  0.1192, -0.3061, -0.1364,  0.3271, -0.1487,
          0.1445, -0.2546, -0.0046,  0.0647,  0.1515,  0.0733, -0.0942, -0.1886},
        {-0.3241, -0.0102,  0.1929, -0.0715,  0.6022, -0.2605,  0.0209,  0.0355,
         -0.0107, -0.0215, -0.0058, -0.2747,  0.4605, -0.6855, -0.1970, -0.4033},
        {-0.0128,  0.2622,  0.5678,  0.0369, -0.0750, -0.1269,  0.4065, -0.4036,
         -0.0168,  0.2727,  0.0558, -0.5105,  0.2983, -0.7235,  0.2971, -0.3607}};
float W_ho[output_size][hidden_size]={{ 0.0286,  0.1163,  0.2600,  0.0242, -0.1616, -0.0062,  0.1314, -0.0209,
          0.0037,  0.1895,  0.1208, -0.2488,  0.0770, -0.1934,  0.3665, -0.7158}};
          
// the bias of RNN          RNN的偏置
float b_ih[hidden_size]={-0.0138,  0.1114, -0.0670,  0.0867, -0.1550, -0.1967,  0.0153, -0.5617,
        -0.0689, -0.0554,  0.1025, -0.2725, -0.0131,  0.1348,  0.2647, -0.1089};
float b_hh[hidden_size]={ 0.0060,  0.0842,  0.0145,  0.1440, -0.2074, -0.0284,  0.0742, -0.2750,
         0.2007, -0.0254, -0.1073,  0.0536, -0.0289,  0.2928, -0.0902, -0.3391};
float b_o[output_size]={-0.2607};


volatile float h[hidden_size];

void setup() {
Serial.begin(19200);
   // initialization of state     初始化状态
  for (int i = 0; i < hidden_size; ++i) {
    h[i] = 0.0;
  }


}

void loop() {
  // input
  float input[input_size] = {count};
  unsigned long startTime = micros();
  
  
    for (int i = 0; i < hidden_size; ++i) {
    h[i] = 0.0;
  }

    //forward  propagation        前向传播
  for (int i = 0; i < hidden_size; ++i) {
    volatile float sum = 0.0;
    for (int j = 0; j < input_size; ++j) {
      sum += W_ih[i][j] * input[j];
    }
    for (int j = 0; j < hidden_size; ++j) {
      sum += W_hh[i][j] * h[j];
    }
    sum += b_ih[i];
    sum += b_hh[i];
    h[i] = tanh(sum);
    // Serial.println(h[i]);
  }

  //output
  float output[output_size] = {0.0};
  for (int i = 0; i < output_size; ++i) {
    volatile float sum = 0.0;
    for (int j = 0; j < hidden_size; ++j) {
      sum += W_ho[i][j] * h[j];
    }
    sum += b_o[i];
    output[i] = tanh(sum);

        // Serial.print("输入：");
        //  Serial.print(count);
        // Serial.print("输出：");
        // Serial.println(output[i]);
        //  delay(4000);  // 延迟一秒钟
     
  }

  unsigned long endTime = micros(); 
  unsigned long executionTime = endTime - startTime;

  Serial.print("the inference time：");
  Serial.print(executionTime);
  Serial.println(" μm");
  // print the memory left 

  size_t freeHeap = ESP.getFreeHeap();
  Serial.print("Available memory：");
  Serial.print(freeHeap);
  Serial.println(" byte");
  count += 1;
    delay(3000);  
}
